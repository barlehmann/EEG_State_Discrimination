{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 235,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install -U mne # with -U means latest STABLE version!\n",
    "#%matplotlib qt\n",
    "import os.path as op\n",
    "import os\n",
    "import numpy as np\n",
    "import mne\n",
    "from mne.time_frequency import tfr_morlet, psd_multitaper, psd_welch\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "from pandas import ExcelWriter\n",
    "from pandas import ExcelFile\n",
    "from pydoc import help\n",
    "from scipy.stats.stats import pearsonr\n",
    "from scipy import linalg\n",
    "from mne import io\n",
    "from mne.connectivity import spectral_connectivity\n",
    "from mne.datasets import sample\n",
    "from mne.viz import plot_sensors_connectivity\n",
    "from entropy import *\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "#This class is for iterating through the raw data and extracting a set of 10 complexity features over a specified seconds_per_sample argument that sets how many seconds \n",
    "# (or samples) are fed into the complexity functions to be put into the final dataframe that will be analysed with later functions.\n",
    "class preprocess_raw:\n",
    "    def __init__(self, seconds_per_sample, filepath=r\"C:\\Users\\barle\\Downloads/AusEC.edf\"):\n",
    "        #For the filepath, it is for the raw data - one can use this as guideline for filepath on a windows pc: raw = mne.io.read_raw_edf(r\"C:\\Users\\barle\\Downloads/AusEC.edf\") \n",
    "        \n",
    "        #Creating basic variables to be used and accessed relating to raw data, its montage (channel settings), channel names, etc.\n",
    "        raw = mne.io.read_raw_edf(filepath)\n",
    "        data = raw.get_data()\n",
    "    \n",
    "        # Below are needed variables in order to streamline this preprocessing class to different EEG recording durations (in seconds)\n",
    "        # More specifically this ensures that feature extraction will be able to loop through a correct number of samples and that remainders \n",
    "        # will not cause any issues\n",
    "        sample_width = seconds_per_sample*raw.info['sfreq']\n",
    "        remainder = len(data.T[:,1])%sample_width\n",
    "        print(remainder)\n",
    "        final_num_samples = len(data.T[:,1]) - remainder \n",
    "        print(final_num_samples)\n",
    "        #CORRECT **NEW** SAMPLE NUMBER  = final_num_samples / sample_width\n",
    "        num_of_new_samples = final_num_samples/sample_width\n",
    "        new_total_duration_seconds = num_of_new_samples / raw.info['sfreq']\n",
    "        new_half_duration_seconds = new_total_duration_seconds / 2\n",
    "        \n",
    "        \n",
    "        # Setting the needed variables to segment two halfs of the data as sample_starts and sample_starts which designate the partitions of \n",
    "        # condition 1 and condition 2 and subsequently creating separate raw selections for designated channels and start and stop times\n",
    "        sampling_freq = raw.info['sfreq']\n",
    "        start_stop_seconds1 = np.array([0, ((len(raw)/sampling_freq)/2)]) #print(len(raw)) # = 92672 / 256 = 362 seconds total / 60  = 6 minutes\n",
    "        start_stop_seconds2 = np.array([((len(raw)/sampling_freq)/2),((len(raw)/sampling_freq))])\n",
    "        start_sample1, stop_sample1 = (start_stop_seconds1 * sampling_freq).astype(int)\n",
    "        start_sample2, stop_sample2 = (start_stop_seconds2 * sampling_freq).astype(int)\n",
    "        channel_index1 = 1\n",
    "        channel_index2 = 1\n",
    "        channel_index3 = 2\n",
    "        channel_index4 = 2\n",
    "        channel_index5 = 3\n",
    "        channel_index6 = 3\n",
    "        channel_index7 = 4\n",
    "        channel_index8 = 4\n",
    "        channel_index9 = 5\n",
    "        channel_index10 = 5\n",
    "        channel_index11= 11\n",
    "        channel_index12 = 11\n",
    "        channel_index13 = 12\n",
    "        channel_index14 = 12\n",
    "        raw_selection1 = data[channel_index1, start_sample1:stop_sample1]\n",
    "        raw_selection2 = data[channel_index2, start_sample2:stop_sample2]\n",
    "        raw_selection3 = data[channel_index3, start_sample1:stop_sample1]\n",
    "        raw_selection4 = data[channel_index4, start_sample1:stop_sample2]\n",
    "        raw_selection5 = data[channel_index5, start_sample1:stop_sample1]\n",
    "        raw_selection6 = data[channel_index6, start_sample1:stop_sample2]\n",
    "        raw_selection7 = data[channel_index7, start_sample1:stop_sample1]\n",
    "        raw_selection8 = data[channel_index8, start_sample1:stop_sample2]\n",
    "        raw_selection9 = data[channel_index9, start_sample1:stop_sample1]\n",
    "        raw_selection10 = data[channel_index10, start_sample1:stop_sample2]\n",
    "        raw_selection11 = data[channel_index11, start_sample1:stop_sample1]\n",
    "        raw_selection12 = data[channel_index12, start_sample1:stop_sample2]\n",
    "        raw_selection13 = data[channel_index13, start_sample1:stop_sample1]\n",
    "        raw_selection14 = data[channel_index14, start_sample1:stop_sample2]\n",
    "\n",
    "        #Below is a bit of additional output for the test file verifying that what is expected to be found has indeed been found related to \n",
    "        #the time durations of a dataset \n",
    "        #print(len(raw)) # = 92672 / 256 = 362 seconds total / 60  = 6 minutes\n",
    "        #print(len(data.T)) # = 92672 / 256 = 362 seconds total / 60  = 6 minutes\n",
    "        #print(len(data.T[:,1])) # = 92672 / 256 = 362 seconds total / 60  = 6 minutes\n",
    "\n",
    "        \n",
    "        \n",
    "        #INDICIES FOR OPTIMAL CHANNELS: 5=C3, 6=C4,7=P3,  8=P4, Fz=17, Cz=18, Pz=19\n",
    "        #These channels are optimal due to their being least likely to be contaminated with artifact\n",
    "\n",
    "\n",
    "        #Below are a set of loops for each channel and each condition which iterate through the sample width and extract the complexity data to create\n",
    "        #the new dataset/dataframe containing these features\n",
    "        #*********************************************************************C3*********************************************************************\n",
    "        nc3 = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection1[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #Below are a few commented commands that helped to test taht the function is working correctly - please ignore if not working on changing this loop \n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            nc3.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 5,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        nc3 = pd.DataFrame(nc3)\n",
    "        #print(pd.DataFrame(nc3))\n",
    "\n",
    "\n",
    "\n",
    "        mc3 = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection2[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mc3.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 5,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mc3 = pd.DataFrame(mc3)\n",
    "        #print(pd.DataFrame(mc3))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        #*********************************************************************C4*********************************************************************\n",
    "\n",
    "\n",
    "\n",
    "        nc4 = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection3[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            nc4.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 6,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        nc4=pd.DataFrame(nc4)\n",
    "        #print(pd.DataFrame(np3))\n",
    "\n",
    "\n",
    "\n",
    "        mc4 = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection4[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mc4.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 6,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mc4=pd.DataFrame(mc4)\n",
    "        #print(pd.DataFrame(mp3))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        #*********************************************************************P3*********************************************************************\n",
    "\n",
    "        np3 = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection5[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            np3.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 7,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        np3=pd.DataFrame(np3)\n",
    "        #print(pd.DataFrame(np3))\n",
    "\n",
    "\n",
    "\n",
    "        mp3 = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection6[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mp3.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 7,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mp3=pd.DataFrame(mp3)\n",
    "        #print(pd.DataFrame(mp3))\n",
    "\n",
    "\n",
    "\n",
    "        #*********************************************************************P4*********************************************************************\n",
    "\n",
    "        np4 = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection7[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            np4.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 8,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        np4=pd.DataFrame(np4)\n",
    "        #print(pd.DataFrame(np4))\n",
    "\n",
    "\n",
    "\n",
    "        mp4 = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection8[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mp4.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 8,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mp4=pd.DataFrame(mp4)\n",
    "        #print(pd.DataFrame(mp4))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        #*********************************************************************FZ*********************************************************************\n",
    "\n",
    "        nfz = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection9[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            nfz.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 17,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        nfz=pd.DataFrame(nfz)\n",
    "        #print(pd.DataFrame(nfz))\n",
    "\n",
    "\n",
    "\n",
    "        mfz = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection10[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mfz.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 17,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mfz=pd.DataFrame(mfz)\n",
    "        #print(pd.DataFrame(mfz))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        #*********************************************************************CZ*********************************************************************\n",
    "\n",
    "        ncz = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection11[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            ncz.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 18,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        ncz=pd.DataFrame(ncz)\n",
    "        #print(pd.DataFrame(ncz))\n",
    "\n",
    "\n",
    "\n",
    "        mcz = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection12[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mcz.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 18,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mcz=pd.DataFrame(mcz)\n",
    "        #print(pd.DataFrame(mcz))\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        #*********************************************************************FZ*********************************************************************\n",
    "\n",
    "        npz = []\n",
    "        j=0\n",
    "        total_samples_container = 0\n",
    "        for i in range(int(num_of_new_samples/2)):\n",
    "            sw = j+sample_width\n",
    "            bin_iteration = raw_selection13[j:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            j += int(sample_width)\n",
    "            #custom_raw = mne.io.RawArray(bin_iteration, info)\n",
    "            #print(custom_raw)\n",
    "            #list1 = mne.time_frequency.psd_welch(raw_selection1, fmin=8, fmax=12, tmin=0, tmax=3, n_fft=256, n_overlap=0, n_per_seg=3, picks=None, proj=False, n_jobs=1, reject_by_annotation=True, average='mean', verbose=None)\n",
    "            #list_alpha=list1[1,1]\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            npz.append(\n",
    "                {\n",
    "                    'condition': 0,\n",
    "                    'time': 3*i,\n",
    "                    #'alpha_amp': list1,\n",
    "                    'channel_index': 19,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        npz=pd.DataFrame(npz)\n",
    "        #print(pd.DataFrame(npz))\n",
    "\n",
    "\n",
    "\n",
    "        mpz = []\n",
    "        p=0\n",
    "        z=0\n",
    "        total_samples_container = 0          \n",
    "        for f in range(int(num_of_new_samples/2)):\n",
    "            sw = p+sample_width\n",
    "            bin_iteration = raw_selection14[p:int(sw)]\n",
    "            total_samples_container += sum(bin_iteration)\n",
    "            p += int(sample_width)\n",
    "            #print(svd_entropy(bin_iteration, order=3, delay=1, normalize=True))\n",
    "            mpz.append(\n",
    "                {\n",
    "                    'condition': 1,\n",
    "                    'time': 3*f+180,\n",
    "                    'channel_index': 19,\n",
    "                    #'avg_alpha_amplitude': o/5,\n",
    "                    'svd_entropy': (svd_entropy(bin_iteration, order=3, delay=1, normalize=True)),\n",
    "                    'perm_entropy': (perm_entropy(bin_iteration, order=3, normalize=True)),\n",
    "                    'spec_entropy':(spectral_entropy(bin_iteration, 100, method='welch', normalize=True)), # Spectral entropy CANNOT USE RAW - MUST USE RAW SELECTION FOR SOME REASON!!!!\n",
    "                    'app_entropy':(app_entropy(bin_iteration, order=2, metric='chebyshev')),              # Approximate entropy\n",
    "                    'sample_entropy':(sample_entropy(bin_iteration, order=2, metric='chebyshev')),           # Sample entropy\n",
    "                    'lziv_complexity':(lziv_complexity(bin_iteration, normalize=True)),        # Lempel-Ziv complexity\n",
    "                    'petrosian_fd':(petrosian_fd(bin_iteration)),            # Petrosian fractal dimension\n",
    "                    'katz_fd':(katz_fd(bin_iteration)),                 # Katz fractal dimension\n",
    "                    'higuchi_fd':(higuchi_fd(bin_iteration, kmax=10)),     # Higuchi fractal dimension\n",
    "                    'detrended_fluctuation':(detrended_fluctuation(bin_iteration))   # Detrended fluctuation analysis\n",
    "                }\n",
    "            )\n",
    "\n",
    "            total_samples_container = 0\n",
    "        mpz=pd.DataFrame(mpz)\n",
    "        #print(pd.DataFrame(mpz))\n",
    "\n",
    "        # Concatenate the dataframes into one\n",
    "        combined_dataframe = pd.concat([nc3, mc3, nc4, mc4, np3, mp3, np4, mp4, nfz, mfz, ncz, mcz, npz, mpz])\n",
    "        print(combined_dataframe.head())\n",
    "        combined_dataframe.to_csv(r\"C:\\Users\\barle\\Downloads/combined_df2.csv\", index = False)\n",
    "        #INDICIES FOR CHANNELS: 5=C3, 6=C4,7=P3,  8=P4, Fz=17, Cz=18, Pz=19\n",
    "\n",
    "\n",
    "# uncomment this to try out the function, of course the filepath can be changed, and so can the desired sample duration (in seconds)\n",
    "a = preprocess_raw(4, filepath=r\"C:\\Users\\barle\\Downloads/AusEC.edf\")        \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 235,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'pandas.core.frame.DataFrame'>\n",
      "<class 'pandas.core.series.Series'>\n",
      "0.5\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1080x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    " numpy as np\n",
    "%matplotlib qt\n",
    "%matplotlib inline\n",
    "import pandas as pd\n",
    "import umap ###install with \"pip install umap-learn\"\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from sklearn.datasets import load_iris\n",
    "from sklearn.metrics import accuracy_score,confusion_matrix\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.cluster import AgglomerativeClustering\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns ### install using pip install seaborn\n",
    "from sklearn.model_selection import GridSearchCV\n",
    "from sklearn.metrics import confusion_matrix\n",
    "from sklearn.svm import SVC\n",
    "import numpy as np\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn import metrics\n",
    "from sklearn.metrics import classification_report, confusion_matrix, accuracy_score\n",
    "import umap ###install with \"pip install umap-learn\"\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from sklearn.datasets import load_iris\n",
    "from sklearn.metrics import accuracy_score,confusion_matrix\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.cluster import AgglomerativeClustering\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns ### install using pip install seaborn\n",
    "from sklearn.model_selection import GridSearchCV\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "import umap \n",
    "#!pip install umap-learn\n",
    "\n",
    "#This class takes in a pandas dataframe - which is also the output of the preprocess_raw function. This class is designed to enable machine \n",
    "#learning algorithms to be performed on the dataset. The attributes of the class split the dataset into the target variables (\"condition\" and \"time\" which are basically providing the same information since\n",
    "# the 1st half of the recording is condition 0, and the second half is condition 1) in the first columns, and the features in the later columns. \n",
    "class complete_dataset:\n",
    "    # demo loads, manipulates, and analyzes a given dataset\n",
    "    def __init__(self, csv):\n",
    "        self.data = csv.drop(['time','condition'], axis=1) \n",
    "        self.target = csv['condition']    \n",
    "        print(type(self.data))\n",
    "        print(type(self.target))\n",
    "        \n",
    "        #IGNORE THIS CODE SEGMENT BELOW (IT IS OTHER CODE THAT MIGHT BE UNCOMMENTED AT LATER EDITIONS TO TWEAK DATATYPES USED OR OTHER ASPECTS)\n",
    "        #csv =df  #pd.read_csv(csv)\n",
    "        #df=pd.DataFrame(csv)\n",
    "        #csv = numpy.array() \n",
    "        #self.target = df.iloc[:, 2] #Getting rid of 'condition' and 'time' as columns since both are main predictors typically put as cols 1&2\n",
    "        ###self.target =  pd.DataFrame(df.iloc[:, 2])\n",
    "        #self.data = df.iloc[:, 2:]\n",
    "        #####self.data =  pd.DataFrame(df.iloc[:, 2:])\n",
    "        #print(type(self.target))\n",
    "        #y = pd.DataFrame(data)\n",
    "        # dataset = combined_dataframe\n",
    "        #data = dataset.drop(['time','condition'], axis=1)\n",
    "        #X = dataset.drop(['time', 'condition'], axis=1)\n",
    "        #print(X)\n",
    "        #print(X.shape)\n",
    "        #labels = dataset['condition']               \n",
    "\n",
    "        \n",
    "    # Methods-----------------------------------------------\n",
    "    \n",
    "    #this method allows for scaling the data\n",
    "    def scale(self):\n",
    "        # We don't expect our data to be Gaussian, so let's use normalization\n",
    "        min_val = self.data.min().min()\n",
    "        max_val = self.data.max().max()\n",
    "        self.scaled_data = (self.data - min_val) / (max_val - min_val)\n",
    "        return self.scaled_data\n",
    "    \n",
    "    #this method allows for dimensionally reducing the data using UMAP and then printing a plot showing clusters within the data in 2 dimensions\n",
    "    def umap(self):\n",
    "        cluster_labels = model.fit_predict(self.scaled_data)\n",
    "        #first, I will reduce dimensions with UMAP so we look at things on a 2-D plane \n",
    "        #(much easier for humans to visualize) \n",
    "        data_reducer = umap.UMAP()\n",
    "        umap_data = data_reducer.fit_transform(scaled_data)\n",
    "        scaled_umap_data = scaler.fit_transform(umap_data)\n",
    "        # add back to a dataframe because it's easier to keep track of things that way \n",
    "        #(all indices and columns have names that we can reference)\n",
    "        reduced_dataset = pd.DataFrame(scaled_umap_data,columns=['Dim. #1', 'Dim. #2'])\n",
    "        #add in our clustering labels from hierarchical clustering \n",
    "        reduced_dataset['cluster_labels'] = cluster_labels\n",
    "        #print(reduced_dataset)\n",
    "        import seaborn as sns\n",
    "        sns.scatterplot(x='Dim. #1', y='Dim. #2',\n",
    "                    hue='cluster_labels', data=reduced_dataset)\n",
    "\n",
    "    #this method performs SVM classification on the data, starting with stratifying the data with splits for cross validation, and subsequently \n",
    "    #printing a confusion matrix showing the results\n",
    "    def svm2(self, C=100, kern='rbf', splits=5, gamma=.1):\n",
    "        svm_model = SVC(kernel='linear')\n",
    "        #svmfit = SVC(kernel=kern).fit(self.data.values, self.target.values)\n",
    "        skf = StratifiedKFold(n_splits=splits)\n",
    "        accuracy = 0\n",
    "        all_feature_importances = np.zeros(11) #len(self.data.columns)\n",
    "        all_labels = []\n",
    "        all_predictions = []\n",
    "        for train_index, test_index in skf.split(self.data.values, self.target.values):\n",
    "            X_train, y_train = self.data.values[train_index], self.target.values[train_index] #''' training dataset '''\n",
    "            X_test, y_test = self.data.values[test_index], self.target.values[test_index] #''' testing dataset '''\n",
    "            svm_model.fit(X_train,y_train)\n",
    "            #all_feature_importances += svm_model.feature_importances_\n",
    "            predictions = svm_model.predict(X_test)\n",
    "            all_predictions.extend(predictions)        \n",
    "            #''' Use extend function to add the new labels onto the list of labels'''\n",
    "            all_labels.extend(y_test)\n",
    "            accuracy += accuracy_score(predictions,y_test)    \n",
    "        cm = confusion_matrix(all_labels,all_predictions,normalize= 'true')#here, I input the labels and predictions into the Scikit learn confusion_matrix function and theywill generate a confusion matrix for me\n",
    "        df_cm = pd.DataFrame(cm,index=[0,1],columns=[0,1])#turn it into a dataframe so seaborn will label the graph using the columns/indicies of the df'''\n",
    "        sns.heatmap(df_cm, annot=True)#graph using seaborn heatmap function - annot=True so labels will appear'''\n",
    "        \n",
    "        #BELOW IS CODE COPIED FROM RF FUNCTION - to do a feature importances table, however, so far have not been able to get it working for SVM\n",
    "        #'' now, I will plot the feature importances so we can decide\n",
    "        #what to do based on our excellent accuracy!'''\n",
    "        #plt.figure(figsize = (15,10))#make the figure a little bigger '''\n",
    "        #''' use matplotlib's bar graph function to graph feature importances\n",
    "        #X axis = feature name\n",
    "        #y axis = feature importance values\n",
    "        #'''\n",
    "        #plt.bar(list(self.data.columns),all_feature_importances/splits, color ='maroon',  width = 0.4) \n",
    "        #plt.title('Feature Importances')\n",
    "        from sklearn.model_selection import GridSearchCV \n",
    "  \n",
    "        #Doing GRID SEARCH FOR SVC:  Can Turn this on by uncommenting the below code if desired\n",
    "        #defining parameter range \n",
    "        #param_grid = {'C': [0.1, 1, 10, 100, 1000],  \n",
    "        #      'gamma': [1, 0.1, 0.01, 0.001, 0.0001], \n",
    "        #      'kernel': ['rbf']}  \n",
    "  \n",
    "        #grid = GridSearchCV(SVC(), param_grid, refit = True, verbose = 3) \n",
    "        # fitting the model for grid search \n",
    "        #grid.fit(X_train, y_train) \n",
    "        # print best parameter after tuning \n",
    "        #print(grid.best_params_)  \n",
    "        # print how our model looks after hyper-parameter tuning \n",
    "        #print(grid.best_estimator_) \n",
    "        return accuracy/splits #, print(), print('ALL LABELS'), print(all_labels), print(), print('ALL PREDICTIONS'), print(all_predictions)\n",
    "    \n",
    "    #this method performs Random Forest classification on the data, starting with stratifying the data with splits for cross validation, and subsequently \n",
    "    #printing a confusion matrix showing the results, as well as a feature importance table\n",
    "    def rand_for(self, n_est = 25, crit = 'gini', splits=5):\n",
    "        rf_model = RandomForestClassifier(n_estimators = n_est,  criterion=crit)\n",
    "        skf = StratifiedKFold(n_splits=splits)\n",
    "        accuracy = 0\n",
    "        all_feature_importances = np.zeros(11) #len(self.data.columns)\n",
    "        all_labels = []\n",
    "        all_predictions = []\n",
    "        for train_index, test_index in skf.split(self.data.values, self.target.values): \n",
    "            X_train, y_train = self.data.values[train_index], self.target.values[train_index]    #''' training dataset '''\n",
    "            X_test, y_test = self.data.values[test_index], self.target.values[test_index]\n",
    "            rf_model.fit(X_train,y_train)\n",
    "            #''' add the new feature importances to the current FI vlues'''\n",
    "            all_feature_importances += rf_model.feature_importances_\n",
    "            predictions = rf_model.predict(X_test)\n",
    "            #''' Use extend function to add the new predictions onto thelist of predictions'''\n",
    "            all_predictions.extend(predictions)        \n",
    "            #''' Use extend function to add the new labels onto the list of labels'''\n",
    "            all_labels.extend(y_test)\n",
    "            accuracy += accuracy_score(predictions,y_test)\n",
    "            #return accuracy/5\n",
    "            \n",
    "        cm = confusion_matrix(all_labels,all_predictions,normalize= 'true')#using labels and predictions into the Scikit learn confusion_matrix function - they generate a confusion matrix\n",
    "        df_cm = pd.DataFrame(cm,index=[0,1],columns=[0,1])#turn it into a dataframe so seaborn will label the graph using the columns/indicies of the df\n",
    "        sns.heatmap(df_cm, annot=True)#graph using seaborn heatmap function - annot=True so labels will appear\n",
    "        #plot the feature importances so we can decide which are most important (while also taking into account overall accuracy scores)!\n",
    "        plt.figure(figsize = (15,10))#make the figure a little bigger\n",
    "        #use matplotlib's bar graph function to graph feature importances\n",
    "        #X axis = feature name\n",
    "        #y axis = feature importance values\n",
    "        plt.bar(list(self.data.columns),all_feature_importances/splits, color ='maroon',  width = 0.4) \n",
    "        plt.title('Feature Importances')\n",
    "        return accuracy/splits \n",
    "\n",
    "    #This function performs a grid search for the best indicies of a random forest\n",
    "    def grid_search(self, n_est = 25, crit = 'gini'):\n",
    "        rf_model = RandomForestClassifier(n_estimators = n_est,  criterion=crit)\n",
    "        parameters = {'n_estimators':(25, 50,75,100,120,1000), 'criterion':['gini', 'entropy']}\n",
    "        self.clf = GridSearchCV(rf_model, parameters)\n",
    "        self.clf.fit(dataset.values,labels)     # HAS NO VALUES OR LABELS HERE!!!!\n",
    "        return clf.best_params_, clf.best_score_ \n",
    "   \n",
    "        \n",
    "########  ----------------------------------------------------------\n",
    "\n",
    "#These are some example commands to begin using this complete dataset class: \n",
    "\n",
    "#If starting from a csv, use this function:\n",
    "data1 = pd.read_csv(r\"C:\\Users\\barle\\Downloads/combined_df2.csv\")\n",
    "data2 = complete_dataset(data1)\n",
    "#print(type(data1))\n",
    "\n",
    "\n",
    "#To scale the data\n",
    "#data3 = data2.scale()\n",
    "#print(type(data3))\n",
    "#print(data3)\n",
    "\n",
    "\n",
    "#The below code performs dimensionality reduction using UMAP, and prints 2D clustering table\n",
    "#dimred = data2.umap()\n",
    "#print(dimred)\n",
    "\n",
    "\n",
    "\n",
    "#The below code performs SVM classification, and prints out confusion matrix\n",
    "#svvmm = data2.svm2(splits=5)\n",
    "#print(svvmm)\n",
    "\n",
    "\n",
    "\n",
    "#The below code performs random forest grid search, and prints out results\n",
    "#gs = data1.grid_search()\n",
    "#print(gs)\n",
    "\n",
    "\n",
    "#The below code performs random forest classification, and prints out confusion matrix as well as a feature importance table\n",
    "#rf = data2.rand_for()\n",
    "#print(rf)\n",
    "\n",
    "\n",
    "\n",
    "#The below generates an error since the scaling method or scaling in itself is not compatible with later methods of the function\n",
    "#scaled_data = data2.scale()\n",
    "#print(type(data3))\n",
    "#print((scaled_data))\n",
    "#data3 = complete_dataset(scaled_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.axes._subplots.AxesSubplot at 0x2288712c7f0>"
      ]
     },
     "execution_count": 145,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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7e1y6tSpUkopP/vZz8p77rlHSillNpuVqVRK1tfXy/nz5w+U/cQTT8irr75aep4nXdeV5513nnzmmWdkfX29FELIF154Yb91mzp16qB6SSllKpWS8+fPlx0dHVJKKYGBetx8883y2muvlVJKefrpp8tNmzZJKaV88cUX5WmnnSallINeW0VFhcxkMlJKKbu7u4etw3C/I2CV3Mf76ljOGrrsHc5L4Nqxen5lbJWW58ZqbNsmm7UIBPx87Zv/jOt5CCCbtXjg3oeZNqMGKSVf++dv86/f/iKO7WCYBlVTykmn08ycO4PGhp00bG/m7p/dz03f/QqapvGbX/yOCy85h6989mZadrYBsHnDNm647pvcdOtXOPWME7jvl7/no9dcys1fvZXnnn6Z2hk1/OAn3yKdzvCNr35v0HjCD2/9GWeffzqpVJpQKDgePzJlFD311FNccsklFBcXA1BYWDii+44//ni+/e1v09TUxMUXX8zMmTOHXPPnP/+ZP//5zyxevBiARCLB5s2bqampYerUqRx33HEjruftt9/OH/7wBwAaGxvZvHkzRUVFaJrGhz70IQCuvPJKLr74YhKJBM8//zwf+MAHBu7PZrNDyly4cCFXXHEFF110ERdddNGI67I/amWxclBM08Q0TSKRMK7rEu+Ls31rE4Zp0N3ZwwevvIhgMMDOphY+85GvUFiUz+0//0/qtzTQ29PH9Td9jksuO5+N67ey7LhFRGMRXNflr4//nSs+dslAENhty6Z6rIzFTTfcwjdvu4Hbvv0j/vG3lwCo37ID23FIpdLsbGoZdJ/juGQzWTRNba91JJBS7ne+vGEYA334e26Fcfnll7N8+XIeffRRzjrrLH72s58xffr0IWV/9atf5ZOf/OSg49u3byccDo+4jk8//TRPPvkkL7zwAqFQiFNPPXWf23IIIfA8j/z8fF5//fX9lvvoo4/y7LPP8sgjj/DNb36TtWvXYhgH91au/iqUUaPrOvkF+Uyrq6GsvISPX3slP/3h3fz6kTu58ANns/Lsk/nej25G1zTuv+dhli5fxAvPvsJ9dz9Ec+MuenvjWFmLVDI3iyibyVJYXDDoOaprKunu6uGFZ1eRl5/HC/9YNaQOr69aw2nvOXnQ8crqcoKhgJqKeoRYuXIl999/P52duXGfrq6uQedra2tZvXo1AA8++ODA8W3btjF9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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
